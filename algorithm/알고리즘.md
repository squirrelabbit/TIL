알고리즘=문제발생&해결방안

# 1. 전력차단

만약 이런 상황이면, 4개면 다행이겠지만 집이 한 1000개쯤 있으면 사람이 이걸 일일히 확인하기 어려울 겁니다.

그래서 아까 설명한 것처럼, For 문을 이용해서 자료를 `체크` 하고 넘어갈건데, 여기서 다양한 방법을 시도해보도록 할게요.

파이썬에서 찾기만 할 거라면, 이런 방법으로도 찾을 수는 있습니다. (containment test → `in`)

```python
# 10개 가구의 실시간 데이터
houses = [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]

if 1 in houses:
    print('전력을 차단하지 말아주세요')
```

그런데 이런 in 은 어떤 로직으로 1이 있는지 없는지 찾는 걸까요?

------

🥇 가장 기본적으로 하나씩 체크를 하는 상황을 생각해 보면, 다음과 같이 나타낼 수 있습니다.

```python
# 10개 가구의 실시간 데이터 

houses = [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]

# 우선 for 문으로 하나하나 돌면서, 1이 있는지를 찾을 수 있습니다.
for house in houses:
    if house == 1:
        print('전력을 차단하지 말아주세요')

# 이렇게 써도 됩니다. 1은 True 라고 평가되기 때문이죠. (0은 False 라고 평가됩니다.)
for house in houses:
    if house:
        print('전력을 차단하지 말아주세요')
```

❓: 그런데, 만약 실시간 데이터를 살펴보니 아무도 전력을 사용하지 않는 다음과 같은 상황이라면

위의 코드로는 설비 작업을 진행할지 말지에 대한 정보를 결국에는 알 수 없습니다.

```python
houses = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

그러면 이런 방법을 사용할 수 있습니다.

💡 어떤 변수를 하나 만들고, 작업을 시작해도 되는지 아닌지 여부를 `담아두면` 되지 않을까?

이때, ready 변수는 flag 로 대체할 수 있습니다.

```python
houses = [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]

# 기본적으로 준비가 됐다고 생각을 하고,
ready = True 

for house in houses:  # 하나씩 돌면서 각각의 집들을 체크해볼건데,
    if house == 1: # 불켜진 집을 하.나.라.도! 발견 했다면?
        ready = False  # 준비가 되지 않았다고 하자!
        
print(ready) # ready 여부를 출력해보자
```

❓ :  그런데 여기서 의문이 생기죠, 찾은 이후에는 꼭 다 돌필요 없는거 아닌가?

`효율성` 에 대해 고민해 봅시다!

```python
houses = [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]
```

💡 기초 자료가 이렇게 되어있다면, 2번 인덱스의 (리스트에서 3번째의) 1을 찾은 이후로는, 그 이후로 더 볼 필요 조차 없습니다. → `break` 를 활용하여 불 켜진 집을 찾는 즉시 포문을 `파괴`하면, 리스트가 길면 길수록 더 효율적인 코드를 작성할 수 있습니다.

```python
ready = True

for house in houses:
    if house == 1:
        ready = False
        break  # 브레이크!!!

print(ready)
```

마지막으로 For - Else 구문을 통해 이렇게도 로직을 작성할 수 있습니다.



# 2. baby-gin 

Q1. Triplet 여부 판단하기

```python
# 내가 받은 카드 목록
cards = [8, 3, 2, 8, 1, 8]
```

☝️ : 이 문제를 풀려면 가장 먼저 해야하는게 뭘까요?

옛날에 반장 선거 기억나시나요? 누가 시킨적은 없지만 멀캠이의 표가 나오면 멀캠이 이름을 적고 그 아래 바를 정 (正) 자를 다들 자연스럽게 적어서 카운트를 했을 거에요.

그러므로, 우선 내가 받은 카드들이 각각 `몇 장 있는지` 정보를 저장하는 `틀`을 만들어야 합니다.

틀은 딕셔너리로 할수도, 그리고 리스트로 할 수도 있죠. → 뭘 쓰느냐 보다는 인간의 자연스러운 사고를 통하여 현실의 정보를 어떻게 구조화 할 수 있을지를 먼저 생각해 보아야 합니다.

→ 여기서 힌트를 얻어 문제를 해결해 보도록 할게요.

------

**<작성 로직>**

1. 우선, 카드는 0~9 밖에 없으니까 → 길이가 10개짜리 리스트를 만들어 줍니다. 카운트 리스트  생성: [0, 0, ... , 0] ⇒ (길이 = 10)
2. 10개짜리 리스트의 각각의 인덱스가 카드 번호를 대표한다고 생각합니다.
3. for 문을 돌면서 주어진 cards 에서 카드 숫자가 하나씩 뽑아져 나올때마다 각각의 인덱스에 바를 정자를 표시해 봅니다 ⇒ 인덱스의 숫자를 1씩 증가시키기.
   1. ex) 3 이 처음으로 나왔다면 [0, 0, 0, + `1` ,0 .... ,0]
4. 해당 작업이 끝났다면 이제는 카운트 리스트를 돌면서 바를 정자가 3개 이상 표시되었는지 확인!
5. 이 과정에서 flag (어떤 문제에서는 answer) 를 활용할 수 있습니다.

**<해답>**

- Answer

```
cards = [8, 3, 2, 8, 1, 8]

card_counts = [0] * 10  # 10 개짜리 틀을 만들어 주고

for num in cards:  # 뽑아져 나올 때마다 
    card_counts[num] += 1

# print(card_counts) => [0, 1, 1, 1, 0, 0, 0, 0, 3, 0]

answer = False

for card_num in card_counts:
    if card_num >= 3:
        answer = True
        break

print(answer)
```

# 3. split(0)

```
email = 'alex@hphk.kr'

real_id = ''  # 일단 id 를 모아줄 변수를 하나 설정하고

for letter in email:  # 문자열을 하나씩 돌아볼건데,
    if letter != '@':  # 골뱅이가 아닌 경우에만
        real_id += letter  # 아까 변수에 모아주고
    else:  # 골뱅이를 발견하는 순간 
        break  # 포문을 파괴하자!

print(real_id)
```



# 4. split(1)

```
customers = 'alex@hphk.kr'
real_id = ''  
print(customers[::-1])

for letter in customers[::-1]: 
  if letter != '@':  # 골뱅이가 아닌 경우에만
	  real_id += letter  # 아까 변수에 모아주고
  else:  # 골뱅이를 발견하는 순간 
	 break  # 포문을 파괴하자!

real_id=real_id[::-1]

print(real_id)
```

# 5. Palindrome

```
word = 'level'
reverse_word = ''

for idx in range(len(word)-1,-1,-1):
	reverse_word +=word[idx]
	
if word == reverse_word:
	print('Palindrome')
```

** range(len(word)-1,-1,-1)/range(len(word))