튜플 vs 리스트

튜플:변하면 안되는것을 넣음

(4,5,6)



## 2] 2차원 리스트 순회하기

❓ 그러면 2차원 리스트는 어떻게 돌아다닐까요? → `순회` 라고 부릅니다.

1차원 리스트는 포문을 써서 자유롭게 돌아다녔듯, 2차원 리스트는 2중 포문으로 돌아다닐 수 있습니다.

1️⃣ 행 우선 순회

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(3):
    for c in range(3):  # r 이 하나 고정된 상태에서 각각 
        trails.append(matrix[r][c])  

print(trails)  # [1, 8, 4, 7, 3, 9, 5, 2, 6]
```

💡 행으로 순회 하긴 하는데 열은 역순으로?

```python
# 행으로 순회 하긴 하는데 열은 역순으로?
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(len(matrix)):  # 사실 range(3) 해도 되겠지만 엄밀히 길이를 잴 수도 있습니다.
    for c in range(len(matrix[0])-1, -1, -1):  # 역순인데, 새끼 리스트의 길이 - 1 시작!
        trails.append(matrix[r][c])

print(trails) # [4, 8, 1, 9, 3, 7, 6, 2, 5]
```

💡 행 우선순회긴 한데, 지그재그로?

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(3):
    if r % 2 == 0:
        for c in range(3):
            trails.append(matrix[r][c])
    elif r % 2 == 1:
        for c in range(2, -1, -1):
            trails.append(matrix[r][c])

print(trails) # [1, 8, 4, 9, 3, 7, 5, 2, 6]
```

------

2️⃣ 열 우선 순회

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []

for r in range(3):
    for c in range(3):
        trails.append(matrix[c][r])  # 여기가 바뀝니다.

print(trails)  # [1, 7, 5, 8, 3, 2, 4, 9, 6]
```

------

3️⃣ 전치하기

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

for r in range(3):
    for c in range(3):
        if r > c:
            matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]

for i in range(3): # 그냥 매트릭스 형태로 보고 싶어서 출력 형식 조정
    print(matrix[i])

# [1, 7, 5]
# [8, 3, 2]
# [4, 9, 6]
```

그런데 전치 자체는 다른 수학적인 의미도 크지만, 문제에서는 어떤 방식으로 바라볼 수 있을까요?

2차원 리스트를 유용하게 쓸 수 있는 경우를 한가지 더 보도록 하겠습니다.

만약 다음과 같이 `항공 노선 현황`이 있다고 하겠습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd11902d-19fb-48a4-a869-739e5f71b1d8/Untitled.png)

💡 그러면 이렇게 길이 이어져 있는 정보는 어떻게 나타낼 수 있을까요?

```python
# 이렇게 하면 되려나? 그런데 만약 노선이 바뀌면 어떻게 하지?

ways = [{'name':'London', 'to':['Paris']},
				{'name':'Rome', 'to':['London']},	
				{'name':'Paris', 'to':['Rome']}]
```

⚠️ 이런 방법 대신 ⇒ `인접 행렬` (Adjacent List)을 통해 표현할 수 있습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/59a88247-5045-4820-8eef-034ae04850e0/Untitled.png)

```python
adjacent_list =  [[0, 0, 1],
									[1, 0, 0]
									[0, 1, 0]]
```

만약 노선이 현 상태의 완전 반대로 된다면? 인접 행렬을 `전치`하면 해결됩니다.

------

+) 나중에 dfs, bfs 탐색 미로 문제를 풀때도 해당 칸에 방문했는지 여부를 조사할 수도 있습니다.

```python
# 방문 체크용 행렬 초기화! 다만 id 가 꼬이지 않게 [0]*3*3 식으로 설정하지 않고
# [[0]*3 for _ in range(3)] 으로 리스트 내포를 통해 생성합니다.

visited =  [[0, 0, 0],
						[0, 0, 0]
						[0, 0, 0]]
```

------

## [3] 딕셔너리 구조화와 비교해보기

❓ 이전의 baby-gin 예제를 리스트로 구조화 했던 것을 기억 하실 거에요

만약, 0~9 정도의 카드라면 이렇게 구조화 하는게 되게 유리할 겁니다.

```python
cards = [1, 3, 2, 5 ,8 ,0, 7 ,5 ,2 ,4 ,8, 4 ,7 ,5 ,2 ,3 ,5, 4, 7, 9]

card_counts = [0]*10

for num in cards:
    card_counts[num] += 1

print(card_counts) # [1, 1, 3, 2, 3, 4, 0, 3, 2, 1]
```

그런데, 초기 조건이 이런식이라면? 뭔가 쓸데없이 0이 공간을 너무 차지하게 됩니다.

고급 알고리즘은 `공간 복잡도` 를 따지게 됩니다. → 지금 경우는 좀 비효율적이죠

```python
cards = [1, 3, 22, 5]

card_counts = [0]*(max(cards)+1)

for num in cards:
    card_counts[num] += 1

print(card_counts)
# [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
```

그러면 이걸 딕셔너리로 구조화 한다면 이렇게 할 수 있습니다.

```python
cards = [1, 3, 22, 5] # 몇개 없는데다 그마저도 떨어져 있다면?

count_dict = dict()  # .get 으로 없는걸 부를땐 None 을 반환합니다.

for num in cards:
    if not count_dict.get(num): # get 은 키값이 없어도 오류가 나지 않습니다.
        count_dict[num] = 1 # 없는 경우는 1을 최초로 넣어줍니다.
    else: # 있는 경우는
        count_dict[num] += 1  # 1을 더해줍니다.

print(count_dict) # {1: 1, 3: 1, 22: 1, 5: 1} -> 순서는 없지만 집계는 가능합니다.
```

- 기본값이 있는 defaultdict 사용 (참고)

  ```python
  from collections import defaultdict
  
  cards = [1, 3, 22, 5]
  
  count_dict = defaultdict(int)
  
  for num in cards:
      count_dict[num] += 1
  
  print(count_dict) # defaultdict(<class 'int'>, {1: 1, 3: 1, 22: 1, 5: 1})
  ```

------

> 💡 **QUESTION : 딕셔너리 구조화 실습예제**

- 김해킹은  **구슬치기 대회**에 참가하였다. 모든 인원은 참가 번호를 부여받는데, 자신과 같은 참가 번호를 가진 사람과 구슬치기 게임을 진행하여야 한다. 단, 반드시 짝이 없는 한 명의 **깍두기**가 존재한다. 참가자들의 참가 번호 정보가 주어질 때, **깍두기의 참가 번호를 출력하시오.**
- 제약 사항:
  - 참가자 번호는 1번부터 시작합니다.
  - 깍두기는 한 명만 존재합니다.
  - 깍두기를 제외한 모든 참가자는 자신의 짝(자신과 같은 수)이 존재합니다.

### 입력 예시

- 첫 줄에는 테스트 케이스 숫자가 들어갑니다.
- 두번째 줄부터 각 테스트 케이스의 참가자들 번호가 공백으로 주어집니다.

```
3
1 3 2 2 1 
3 7 100 21 13 6 5 7 5 6 3 13 21
9 1 8 7 71 33 62 35 11 4 7 71 33 8 9 1 4 11 35
```

- 출력 예시

 ```
  #1 3
  #2 100
  #3 62
 ```

- Answer

  ```python
  T = int(input())  # 테스트 케이스 숫자를 받습니다.
  
  for tc in range(1, T+1):
      nums = list(map(int, input().split()))  # 참가자들 번호를 받습니다.
  
      count_dict = dict()  # 일단은 딕셔너리로 구조화 하기
  
      for num in nums:  # 구조화 로직
          if not count_dict.get(num):
              count_dict[num] = 1
          else:
              count_dict[num] += 1
  
      answer = 0  # 깍두기를 담을 정답 변수
  
      for key, val in count_dict.items():
          if count_dict[key] == 1: # 돌다가 혼자다?
              answer = key  # 찾았다
              break  # 조금이라도 효율성 챙기기
  
      print('#{} {}'.format(tc, answer))  # 문자열 포매팅
  ```

- Answer2 (참고, XOR 비트연산)

  ```python
  T = int(input())  # 테스트 케이스 숫자를 받습니다.
  
  for tc in range(1, T+1):
      nums = list(map(int, input().split()))  # 참가자들 번호를 받습니다.
      answer = 0
  
      for num in nums:
          answer = answer ^ num  # XOR 연산하며 for 돌기
  
      print('#{} {}'.format(tc, answer))  # 문자열 포매팅
  ```