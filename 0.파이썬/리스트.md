# 1차원 리스트

## 리스트 연산

더하기는 그냥 길이만늘어남

곱셈도 마찬가지

따라서 포문 으로 i  하나하나해줘야함

| 합집합     | a \| b | union = list(set(lst1) \| set(lst2))<br />union = list(set().union(lst1,lst2)) |
| ---------- | ------ | ------------------------------------------------------------ |
| 교집합     | a & b  | intersection = list(set(lst1) & set(lst2))<br />intersection = list(set(lst1).intersection(lst2)) |
| 차집합     | a - b  | set.difference(a, b)                                         |
| 대칭차집합 | a ^ b  | set.symmetric_difference(a, b)                               |



## 리스트 삽입 & 삭제

### 1. append(원소)

   - 리스트 맨 끝에 새로운 원소를 추가합니다.
   - O(1)의 시간 복잡도를 가집니다.

   ```python
   a = [1, 2, 3, 4, 5]
   a.append(6)
   
   print(a)
   # [1, 2, 3, 4, 5, 6]
   ```

   ```python
   a = [1, 2, 3, 4, 5]
   a.append(["a", "b"])
   
   print(a)
   # [1, 2, 3, 4, 5, ["a", "b"]]
   ```

### 2.pop(인덱스)

   - 특정 인덱스의 값을 삭제하면서 동시에 반환합니다.
   - pop() → O(1)
   - pop(i) → O(n)

   ```python
   a = [1, 2, 3, 4, 5]
   b = a.pop()
   
   print(a)
   print(b)
   # [1, 2, 3, 4]
   # 5
   ```

   ```python
   a = [1, 2, 3, 4, 5]
   b = a.pop(2)
   
   print(a)
   print(b)
   # [1, 2, 4, 5]
   # 3
   ```

   - pop(0) 을 하는 경우 맨 앞에서부터 뽑을 수 있습니다.

## 리스트 관련 내장 함수

### 1.len()

   - 입력 값의 `길이`(원소의 개수)를 반환하는 함수입니다.

     ```python
     a = [1, 2, 3, 4, 5]
     
     print(len(a))
     # 5
     ```

### 2.sum()

   - 입력 받은 iterable의 모든 원소의 `합`을 반환하는 함수입니다.

     ```python
     a = [1, 2, 3, 4, 5]
     
     print(sum(a))
     # 15
     ```

### 3.max()

   - 입력 받은 iterable의 원소 중 `최댓값`을 반환하는 함수입니다.

     ```python
     a = [1, 2, 3, 4, 5]
     
     print(max(a))
     # 5
     ```

### 4.min()

   - 입력 받은 iterable의 원소 중 `최솟값`을 반환하는 함수입니다.

     ```python
     a = [1, 2, 3, 4, 5]
     
     print(min(a))
     # 1
     ```

### 5.sorted()

   - 입력 받은 iterable을 `오름차순으로 정렬`한 후 그 결과를 리스트로 반환하는 함수입니다.

   - 새로운 리스트를 만드는 것이므로 기존 값에 직접적으로 변화를 주지는 않습니다.

   - **옵션**

     - `key` : 어떤 기준으로 정렬할 것인지 정하는 옵션. (`함수`를 지정하여 기준을 정함)
     - `reverse` : 내림차순으로 정렬할 것인지 정하는 옵션. (기본값: `False`)

     ```python
     a = [3, 1, -1, 5, 2]
     
     print(sorted(a))
     # [-1, 1, 2, 3, 5]
     
     print(sorted(a, reverse=True))
     # [5, 3, 2, 1, -1]
     ```

     ```python
     a = [("a", 5), ("b", 3), ("c", 4)]
     
     print(sorted(a, key=lambda x: x[1])) # 튜플의 1번째 원소를 기준으로 정렬
     # [("b", 3), ("c", 4), ("a", 5)]
     ```

### 6.reversed()

   - 입력 받은 iterable의 `순서를 거꾸로 바꿔서 반환`하는 함수입니다.

   - `a[::-1]`과 비슷한 기능을 수행합니다.

   - 반환 값이 리스트가 아니므로, 별도의 타입 변환을 해줘야 합니다.

     ```python
     a = [1, 2, 3, 4, 5]
     
     print(reversed(a))
     # <list_reverseiterator at 0x256e3f576a0>
     
     print(list(reversed(a))) # 타입 변환
     # [5, 4, 3, 2, 1]
     ```

### 7.zip()

   - 여러 iterable을 대상으로 `같은 인덱스 원소끼리 묶어서 튜플로 반환`하는 함수입니다.

   - 반환 값이 리스트가 아니므로, 별도의 타입 변환을 해줘야 합니다.

     ```python
     a = [1, 2, 3]
     b = [4, 5, 6]
     c = [7, 8, 9]
     
     print(zip(a, b, c))
     # <zip at 0x256e4093e40>
     
     print(list(zip(a, b, c)))
     # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
     ```

   - 2차원 리스트에 zip 함수와 Unpacking을 이용하면 `행과 열을 스위칭` 할 수 있습니다.

### 8.join()

   - join 함수는 매개변수로 들어온 리스트에 있는 요소 하나하나를 합쳐서 하나의 문자열로 바꾸어 반환하는 함수입니다.

   - join 함수는 모든 반복 자료형의 데이터를 **`하나의 문자열`**로 합치는 기능을 수행

   -  **'구분자'.join(리스트)**

   - [파이썬에서 비 `str` 목록을 문자열로 변환](https://www.delftstack.com/ko/howto/python/how-to-convert-a-list-to-string/#파이썬에서-비-str-목록을-문자열로-변환)

     `join` 메소드에는 주어진 **매개 변수로 `str` 데이터 유형이 필요**합니다. 따라서 `int`형식 목록에 가입하려고하면 `TypeError` 가 표시됩니다.

     ```python
     >>> a = [1,2,3]
     >>> "".join(a)
     Traceback (most recent call last):
       File "<pyshell#1>", line 1, in <module>
         "".join(a)
     TypeError: sequence item 0: expected str instance, int found
     ```

     `int` 타입은 결합되기 전에 `str` 타입으로 변환되어야합니다.

     ```python
     >>> a = [1,2,3]
     >>> "".join([str(_) for _ in a])
     "123"
     >>> a = [1,2,3]
     >>> "".join(map(str, a))
     '123'
     
     ```

     (http://book.pythontips.com/en/latest/map_filter.html#map)
     
     
     `map` 함수는 `str` 함수를 목록 `a` 의 모든 항목에 적용하고 반복 가능한 `map` 객체를 반환합니다.
     
     `"".join()`은 `map` 객체의 모든 요소를 반복하고 연결된 요소를 문자열로 반환합니다.
          출처: https://blockdmask.tistory.com/468 [개발자 지망생]



### 9.map

map은 리스트의 요소를 지정된 함수로 처리해주는 함수

map은 원본 리스트를 변경하지 않고 새 리스트를 생성

- list(map(함수, 리스트))
- tuple(map(함수, 튜플))

```
 a = [1.2, 2.5, 3.7, 4.6]
 for i in range(len(a)):
    a[i] = int(a[i])

 a
[1, 2, 3, 4]
```

```
 a = [1.2, 2.5, 3.7, 4.6]
 a = list(map(int, a))
 a
[1, 2, 3, 4]
```



------

## List Comprehension

`가독성` 뿐만 아니라, 리스트를 만드는 용으로만 사용한다는 `의도`를 잘 표현

 for문을 풀어서 작성하는 것보다 `속도` 면에서도 우월


1. append 방법

   ```
   numbers = []
   for i in range(5):
   		numbers.append(i)
   print(numbers)
   
   # [0, 1, 2, 3, 4]
   ```

   


2. List Comprehension
   ```
   numbers = [i for i in range(5)]
   print(numbers)
   # [0, 1, 2, 3, 4]




3. map, filter 함수 대신 사용하기

- List Comprehension을 이용해 `map, filter 함수를 완전히 대체`


(1) map 함수 대신 사용하기
  ```python
numbers = [i for i in range(5)]

print(numbers)

# [0, 1, 2, 3, 4]
  ```

------

# 2차원 리스트

### (1) List Comprehension

```python
# 2차원 리스트 입력 받을 때 자주 사용하는 패턴

n = int(input())
board = [list(map(int, input())) for _ in range(n)]
```

- List Comprehension을 이용해서 `n개의 라인`을 2차원 리스트 형태로 입력 받을 수 있습니다.

- 실제 board가 가지는 2차원 리스트는 아래와 같은 모습

  ![2차배열.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/%EB%A6%AC%EC%8A%A4%ED%8A%B8.assets/2%EC%B0%A8%EB%B0%B0%EC%97%B4.png?raw=true)

```python
i,j = list(map(int,input().split())) #행,열
#연산자 for문
array = [[0]*j for _ in range(i)]
#2중 for문
array = [[0 for col in range(j)] for row in range(i)]
```

```
연산자 *로 2중 리스트 선언
array = [[0]*11 ]*10

```

이 방법으로 배열을 선언하게 되면, 단순히 요소를 복사하게 되는 **얕은복사 (shallow copy)**가 일어난다. 단순히 요소를 복사하다 보니 바라보는 객체는 동일하다. 즉, 이러한 방식으로 선언 뒤에, 값을 변경하게되면 다른 원소들도 값이 변경되는 현상이 발생하게 되므로 이를 인지하고, 후에 대입연산자를 통해 값을 변경하지 않는 경우에만 사용하는것이 좋다.

- 2중 리스트 출력

 ```python
  for i in array :
      for j in i:
          print(j,end=" ")# 기본으로 있는\n을 없애줌
      print()
 ```

### (2)numpy 

np.array

- np.zeros((2, 3)):영행렬

  **np.zeros(shape, dtype, order)**

  np.zeros(shape=(10,), dtype=np.int8)

  np.zeros((2,5))

- arr = np.ones((3, 3)):일행렬

- np.arange(30) 

  \# range : List의 range와 같은 효과, integer로 0부터 29까지 배열 추출*

  np.arange(0, 5, 0.5-간격) 

  *# floating point 도 표시가능함* 

  

1차원 리스트를 reshape해서 2차원 배열을 생성 

- arr = np.array([5] * 15).reshape((3, 5)) print(arr)
- arr = np.arange(25).reshape((5, 5))



튜플 vs 리스트

튜플:변하면 안되는것을 넣음

(4,5,6)



##  2차원 리스트 순회하기

❓ 그러면 2차원 리스트는 어떻게 돌아다닐까요? → `순회` 라고 부릅니다.

1차원 리스트는 포문을 써서 자유롭게 돌아다녔듯, 2차원 리스트는 2중 포문으로 돌아다닐 수 있습니다.

1️⃣ 행 우선 순회

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(3):
    for c in range(3):  # r 이 하나 고정된 상태에서 각각 
        trails.append(matrix[r][c])  

print(trails)  # [1, 8, 4, 7, 3, 9, 5, 2, 6]
```

💡 행으로 순회 하긴 하는데 열은 역순으로?

```python
# 행으로 순회 하긴 하는데 열은 역순으로?
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(len(matrix)):  # 사실 range(3) 해도 되겠지만 엄밀히 길이를 잴 수도 있습니다.
    for c in range(len(matrix[0])-1, -1, -1):  # 역순인데, 새끼 리스트의 길이 - 1 시작!
        trails.append(matrix[r][c])

print(trails) # [4, 8, 1, 9, 3, 7, 6, 2, 5]
```

💡 행 우선순회긴 한데, 지그재그로?

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(3):
    if r % 2 == 0:
        for c in range(3):
            trails.append(matrix[r][c])
    elif r % 2 == 1:
        for c in range(2, -1, -1):
            trails.append(matrix[r][c])

print(trails) # [1, 8, 4, 9, 3, 7, 5, 2, 6]
```

------

2️⃣ 열 우선 순회

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

trails = []

for r in range(3):
    for c in range(3):
        trails.append(matrix[c][r])  # 여기가 바뀝니다.

print(trails)  # [1, 7, 5, 8, 3, 2, 4, 9, 6]
```

------

3️⃣ 전치하기

```python
matrix = [[1, 8, 4], 
					[7, 3, 9], 
					[5, 2, 6]]

for r in range(3):
    for c in range(3):
        if r > c:
            matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]

for i in range(3): # 그냥 매트릭스 형태로 보고 싶어서 출력 형식 조정
    print(matrix[i])

# [1, 7, 5]
# [8, 3, 2]
# [4, 9, 6]
```

그런데 전치 자체는 다른 수학적인 의미도 크지만, 문제에서는 어떤 방식으로 바라볼 수 있을까요?

2차원 리스트를 유용하게 쓸 수 있는 경우를 한가지 더 보도록 하겠습니다.

만약 다음과 같이 `항공 노선 현황`이 있다고 하겠습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd11902d-19fb-48a4-a869-739e5f71b1d8/Untitled.png)

💡 그러면 이렇게 길이 이어져 있는 정보는 어떻게 나타낼 수 있을까요?

```python
# 이렇게 하면 되려나? 그런데 만약 노선이 바뀌면 어떻게 하지?

ways = [{'name':'London', 'to':['Paris']},
				{'name':'Rome', 'to':['London']},	
				{'name':'Paris', 'to':['Rome']}]
```

⚠️ 이런 방법 대신 ⇒ `인접 행렬` (Adjacent List)을 통해 표현할 수 있습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/59a88247-5045-4820-8eef-034ae04850e0/Untitled.png)

```python
adjacent_list =  [[0, 0, 1],
									[1, 0, 0]
									[0, 1, 0]]
```

만약 노선이 현 상태의 완전 반대로 된다면? 인접 행렬을 `전치`하면 해결됩니다.

------

+) 나중에 dfs, bfs 탐색 미로 문제를 풀때도 해당 칸에 방문했는지 여부를 조사할 수도 있습니다.

```python
# 방문 체크용 행렬 초기화! 다만 id 가 꼬이지 않게 [0]*3*3 식으로 설정하지 않고
# [[0]*3 for _ in range(3)] 으로 리스트 내포를 통해 생성합니다.

visited =  [[0, 0, 0],
						[0, 0, 0]
						[0, 0, 0]]
```

------

## 딕셔너리 구조화와 비교

❓ 이전의 baby-gin 예제를 리스트로 구조화 했던 것을 기억 하실 거에요

만약, 0~9 정도의 카드라면 이렇게 구조화 하는게 되게 유리할 겁니다.

```python
cards = [1, 3, 2, 5 ,8 ,0, 7 ,5 ,2 ,4 ,8, 4 ,7 ,5 ,2 ,3 ,5, 4, 7, 9]

card_counts = [0]*10

for num in cards:
    card_counts[num] += 1

print(card_counts) # [1, 1, 3, 2, 3, 4, 0, 3, 2, 1]
```

그런데, 초기 조건이 이런식이라면? 뭔가 쓸데없이 0이 공간을 너무 차지하게 됩니다.

고급 알고리즘은 `공간 복잡도` 를 따지게 됩니다. → 지금 경우는 좀 비효율적이죠

```python
cards = [1, 3, 22, 5]

card_counts = [0]*(max(cards)+1)

for num in cards:
    card_counts[num] += 1

print(card_counts)
# [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
```

그러면 이걸 딕셔너리로 구조화 한다면 이렇게 할 수 있습니다.

```python
cards = [1, 3, 22, 5] # 몇개 없는데다 그마저도 떨어져 있다면?

count_dict = dict()  # .get 으로 없는걸 부를땐 None 을 반환합니다.

for num in cards:
    if not count_dict.get(num): # get 은 키값이 없어도 오류가 나지 않습니다.
        count_dict[num] = 1 # 없는 경우는 1을 최초로 넣어줍니다.
    else: # 있는 경우는
        count_dict[num] += 1  # 1을 더해줍니다.

print(count_dict) # {1: 1, 3: 1, 22: 1, 5: 1} -> 순서는 없지만 집계는 가능합니다.
```

- 기본값이 있는 defaultdict 사용 (참고)

  ```python
  from collections import defaultdict
  
  cards = [1, 3, 22, 5]
  
  count_dict = defaultdict(int)
  
  for num in cards:
      count_dict[num] += 1
  
  print(count_dict) # defaultdict(<class 'int'>, {1: 1, 3: 1, 22: 1, 5: 1})
  ```

------

> 💡 **QUESTION : 딕셔너리 구조화 실습예제**

- 김해킹은  **구슬치기 대회**에 참가하였다. 모든 인원은 참가 번호를 부여받는데, 자신과 같은 참가 번호를 가진 사람과 구슬치기 게임을 진행하여야 한다. 단, 반드시 짝이 없는 한 명의 **깍두기**가 존재한다. 참가자들의 참가 번호 정보가 주어질 때, **깍두기의 참가 번호를 출력하시오.**
- 제약 사항:
  - 참가자 번호는 1번부터 시작합니다.
  - 깍두기는 한 명만 존재합니다.
  - 깍두기를 제외한 모든 참가자는 자신의 짝(자신과 같은 수)이 존재합니다.

### 입력 예시

- 첫 줄에는 테스트 케이스 숫자가 들어갑니다.
- 두번째 줄부터 각 테스트 케이스의 참가자들 번호가 공백으로 주어집니다.

```
3
1 3 2 2 1 
3 7 100 21 13 6 5 7 5 6 3 13 21
9 1 8 7 71 33 62 35 11 4 7 71 33 8 9 1 4 11 35
```

- 출력 예시

 ```
 #1 3
 #2 100
 #3 62
 ```

- Answer

  ```python
  T = int(input())  # 테스트 케이스 숫자를 받습니다.
  
  for tc in range(1, T+1):
      nums = list(map(int, input().split()))  # 참가자들 번호를 받습니다.
  
      count_dict = dict()  # 일단은 딕셔너리로 구조화 하기
  
      for num in nums:  # 구조화 로직
          if not count_dict.get(num):
              count_dict[num] = 1
          else:
              count_dict[num] += 1
  
      answer = 0  # 깍두기를 담을 정답 변수
  
      for key, val in count_dict.items():
          if count_dict[key] == 1: # 돌다가 혼자다?
              answer = key  # 찾았다
              break  # 조금이라도 효율성 챙기기
  
      print('#{} {}'.format(tc, answer))  # 문자열 포매팅
  ```

- Answer2 (참고, XOR 비트연산)

  ```python
  T = int(input())  # 테스트 케이스 숫자를 받습니다.
  
  for tc in range(1, T+1):
      nums = list(map(int, input().split()))  # 참가자들 번호를 받습니다.
      answer = 0
  
      for num in nums:
          answer = answer ^ num  # XOR 연산하며 for 돌기
  
      print('#{} {}'.format(tc, answer))  # 문자열 포매팅
  ```



## 2차원 문제

### **Q1. 지그재그 배열**

**\**[출처]\** [[Python\]파이썬 2차원 리스트(이차원배열)](https://blog.naver.com/euijun54/221607532990)|\**작성자\** [어준](https://blog.naver.com/euijun54)**

**1) 2차원 리스트 만들기**

처음부터 리스트안에 행과 열의 크기를 정해서 적어줘도 되지만, input을 사용해서 행과 열의 크기를 받아보았다.

![20190802170122.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170122.png?raw=true)

java나 c언어에서는 [ ][ ]이런 식으로 중괄호 두개를 연속으로 붙여서 사용했지만, 파이썬에서는 

[[] *i for k in range(j)]이런식으로 사용해준다.

![20190802165953.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802165953.png?raw=true)







**2) 사용할 변수 만들어 주기**

![20190802170130.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170130.png?raw=true)

다 이해가는데 sw가 어디에 사용하는지 이해가 안갈 수 있는데 sw는 start부터 end까지의 증가치이면서 마지막에 부호를 바꿔주기 위해 만들어 놓은 변수이다. 밑에서 확인해 보자.



****

**3) for문 사용하기**

기본적으로 행과 열을 사용하기 때문에  이중 for문을 사용할 것이다.

![20190802170142.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170142.png?raw=true)

for j in range(start , end +sw ,sw):  j를 (0,data[0]의 길이 +1,1)의 형식으로 반복한다 

n +=1  :  for 문이 시작되면 n에 1씩 증가시킨다. 값을 저장시킨다 생각하면된다.

data[i][j] += n  : 그리고 이제 j 에 그 값을 더해준다

여기까지 쓰면 만약 data[0]의 길이가 5 였을 때  5개의 숫자가 순서대로 출력이 된다(for 문에서는 최대치-1만큼 출력이 되기때문에 +1을 해줘야 한다.)



그리고 이렇게 for문이 한번끝나면 한 행이 완료가 된것이다.

완료가 되면 start값과 end값을 바꿔주고, sw를 -로 만들어주기위해 -1을 곱해준다.

그렇게면 지금까지 12345 식으로 값이 증가했다면 이제 

for j in range(5, 0+1 , -1) 로 값이 1만큼 줄어드는 반복문이 된다.

그러면 10 9 8 7 6 이라는 숫자가 나오게 된다.

그리고 그반복이 끝나면 다시 start와 end값을 바꾸고, 다시 부호를 바꿔주서 처음의 반복문 형태로 바뀌게 된다.





**4) 출력**

![20190802170150.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170150.png?raw=true)

그리고나서 출력해보면 다음과 같이 출력이 된다.

![20190802170157.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170157.png?raw=true)



****

### **Q2. 달팽이 모양**

****

**1) 리스트 및 변수만들기**

위와  쓰는 변수는 거의 비슷하지만 k라는 변수가 하나 더 있다.

k는 각 반복 작업후에 횟수를 줄이고 0이되면 반복을 종료시키는 변수이다.

!![20190802170225.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170225.png?raw=true)



이번에는 언제 종료될지 모르기 때문에 while문을 사용할 것이다.

그러다 수행횟수를 나타내는 k가 0이되면 반복문을 종료하는 break를 사용한다



![20190802170235.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170235.png?raw=true)

 식은 위와 같다. 글로 쓰기에는 무리가 있어서 옆에 주석을 두었으니 직접 실행해보길 바란다.

출력방식은 위에서 사용했던 방식과 같다.

![20190802170240.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170240.png?raw=true)



출력값

![20190802170245.png](https://github.com/squirrelabbit/TIL/blob/master/0.%ED%8C%8C%EC%9D%B4%EC%8D%AC/2%EC%B0%A8%EC%9B%90%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%AC%B8%EC%A0%9C.assets/20190802170245.png?raw=true)



**[출처]** [[Python\]파이썬 2차원 리스트(이차원배열)](https://blog.naver.com/euijun54/221607532990)|**작성자** [어준](https://blog.naver.com/euijun54)