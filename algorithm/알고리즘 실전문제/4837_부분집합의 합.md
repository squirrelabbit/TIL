# 4837_부분집합의 합

# 1. 메모리에러(용량이큰듯....->해석오류)

```python
T = int(input()) # 케이스 갯수

for tc in range(1, T+1): # 케이스 1~ T까지
    NK = list(map(int, input().split()))
    
    N = NK[0]  # 원소 갯수
    K = NK[1]  # 원소 합의 값
    
    # 문제로직
    
    # 0 / 공집합
    # 0+1 / N=1
    # 0+2, 0+1+2 / N=2
    # 0+3, 0+1+3, 0+2+3, 0+1+2+3 N=3

    sum_list = [0] # 공집합의 합

    for j in range(1,N+1): # 1~N까지 반복
        for i in sum_list: #기존 리스트에 n을 각각 더해줌
            sum_list.append(i+N)  
    
    answer = sum_list.count(K)
    
    #최종 출력 예시
    print('#{} {}'.format(tc, answer))
```

```
sum_list.append(i+N)  
MemoryError

```

> 문제를 제대로 읽지않음 N은 원소갯수가아니라 부분집합원소의 갯수
>
> 원래집합A는 정해져있다 N에따라서 바뀌지않는다

# 2. 두번째시도(비트연산자)

## 부분집합 이론 정리

**◾ Bit로 생각해보기**

[a.b.c.d]

앞서 부분 집합을 구하는 방법을 소개하며 '**이진수**'로 생각해보면 이해가 쉽다고 언급했다. 앞선 코드에서는 크기 4(원소가 4개)인 집합의 bit 리스트를 생성하기 위해 for문을 4번이나 중첩했다. 그러나 'bit'리스트를 이진수로 생각해보면 다음과 같다.



![img](https://blog.kakaocdn.net/dn/dzTcuW/btrlEnIAcvQ/k4KRbBnAKqfYCKsGJke071/img.png)



즉 반복문을 4번이나 중첩시키는 대신, 이진수 값을 1씩 증가시키는 편이 더욱 효율적인 방법이 되겠다. 이 원리를 바탕에 둔 방법이 바로 다음에 이어진다.

------
**◾ 비트 연산자**

**비트 연산자** : 0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자이다.

📌 비트 연산자 종류
\- &  : 비트 단위로 AND 연산을 한다.
\- |   : 비트 단위로 OR 연산을 한다. (키보트 Enter 키 위에 있는 "\키+Shift"로 쓸 수 있다.)
\- << : 피연산자의 비트 열을 왼쪽으로 이동시킨다. 1<<2 100>>2 
\- >> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

------

**◾ 비트 연산자를 이용, 부분 집합을 구하기 위한 'bit' 만들기**

> **1)
> 
> **예제) **2 << 3** : '10'(2의 2진수 표현)을 왼쪽으로 3만큼 이동한다.
> 결과 -> 10000 -> **16**
>
> 1<<0 = 1
> 1<<1 = 2
> 1<<2 = 4
> 1<<3 = 8
> ...
> 📌1<<n = 2^n = 원소가 n개일 경우의 모든 부분 집합의 수!
>
> **2)
> 
> **예제) **5 & 3** : 이진수 '5'와 3'의 비트 단위 기준, 자릿수 별로 OR연산을 한다.
> 결과 -> 5 & 3 -> 101(5의 2진수 표현) & 011(3의 2진수 표현) -> 010 -> **2
> 
> **
> 10(1010) & 1(0001) = 0
> 10(1010) & 2(0010) = 1
> 10(1010) & 4(0100) = 0
> 10(1010) & 8(1000) = 1
>
> **3)**
> 1번과 2번을 모두 활용하면 다음과 같이 쓸 수 있다.
> 10(1010) & 1<<0 = 0
> 10(1010) & 1<<1 = 1
> 10(1010) & 1<<2 = 0
> 10(1010) & 1<<3 = 1
>
> 즉,
> **📌****i & (1<<j)** : i에서 오른쪽으로부터 j+1번째 비트가 1인지 0인지를 리턴한다.

------

**◾ 보다 간결하게 부분 집합을 생성하는 방법**

```
arr = [1, 3, 5, 8]
n = len(arr)    # n : 원소의 개수(4개)

for i in range(1<<n):    # 1<<n : 부분 집합의 개수 =2의 n승개 n =2개 1<<2 100 4
    temp = []    # temp : 부분 집합을 저장할 임시 리스트 초기화
    for j in range(n):    # 원소의 수만큼 비트를 비교함
        if i&(1<<j):  #i의 j번째 비트가 1이면 True
            temp.append(arr[j])    # 비트가 1에 해당하는 원소를 부분 집합 리스트에 추가
    print(temp)    #부분 집합 출력
```

위 코드를 실행하면 다음과 같은 결과가 나온다.

 

> [] [1] [3] [1, 3] [5] [1, 5] [3, 5] [1, 3, 5] [8] [1, 8] [3, 8] [1, 3, 8] [5, 8] [1, 5, 8] [3, 5, 8] [1, 3, 5, 8]

 출처: [[SWEA\]파이썬 SW문제해결 기본 - LIST 2 : 부분 집합 (1/2) (tistory.com)](https://taewow.tistory.com/22)


## 파이썬 부분집합 만들기

```python
arr = [1,2,3,4,5,6,7,8,9,10,11,12] #원집합
n=len(arr) 
sub=[] #부분집합 리스트
for i in range(1<<n): #부분집합의 개수만큼 실행 
	element=[] 
    for j in range(n): 
        if i&(1<<j): 
            element.append(arr[j]) 
        sub.append(element)

출처: https://j-ungry.tistory.com/142 [정구리의 우주정복]
```
## 부분집합의 합 구하기

```python
T = int(input())


for tc in range(1,T+1):
    N,K = map(int, input().split())
    A = [i for i in range (1,13)]
    # 리스트 컴프리헨션참고 *
------------------------------------------
	#부분집합구하기
    subset = []
    for i in range(1<<12): #2의 12승개
    	element = []
        for j in range(12):
            if i & (1<<j):
                element.append(A[j])
        if len(element) == N:
            subset.append(element)
            
------------------------------------------
	#부분집합 합구하기
    count = 0
    for i in range(len(subset)):
        total = 0
        for j in subset[i]:
            total += j
        if total == K:
            count += 1
         
    print("#{} {}".format(tc, count))
```

문제의 흐름을 정리해봅시다.

 

1.문제에서 요구한대로 1부터 12까지의 숫자 리스트를 형성해줍니다.
2.비트연산중 shift연산자를 사용하였습니다.

```
ex)
1 << 0 이면 1 (이진수)
1 << 1 이면 10 (이진수)
1 << 2 이면 100 (이진수)
1 << 4 10000 이고 2^4인 16이다.
즉 numbers = [1,2,3,4,5,6,7,8,9,10,11,12] 이므로 총 1<< 12 == 1000000000000(이진수) == 2^12 ==5048 만큼 돈다는 것입니다.
```

3.빈 부분집합 리스트를 만드는데 if i & (1 << j) 이 구문이 생소할 수 있습니다. 간단히 설명하자면

&는 AND를 찾는 비트연산자로, 예를 들어 A & B에서 A와 B의 2진수 형태에서 공통된 값을 10진수로 변환해 리턴해주는 역할을 합니다.

```
예시)
print(5 & 4)
=>4
```

위의 예시는 4를 리턴해줍니다. 5의 2진수 형태는 101이고, 4의 2진수 형태는 100입니다. 그러므로 5와 4의 교집합은 100이기 때문에 이것을 10진수로 변환해 4를 출력합니다.

 

즉 i와 2의 j승이 지정된 범위안에서 교집합이면 부분집합 리스트에 넣어줍니다. 그 후 부분집합리스트를 만들어준 리스트(lst)에 넣어줍니다.

 

이 리스트(lst)를 가지고 만약 리스트의 길이가 N이고 리스트의 합이 K이면 count에 1을 더해줍니다.



출처: https://totoma3.tistory.com/118 [토토모의 분석일지]



# 3. combination함수 사용

```python
import itertools 
Test_case = int(input()) 
numbers = [i for i in range(1,13)] 
for t in range(1,Test_case+1): 
    N,K = map(int,input().split()) 
    combi = list(itertools.combinations(numbers,N)) 
    count = 0 
    for i in combi: 
        if sum(i)==K: 
            count+=1 print('#{} {}'.format(t, count))

출처: https://totoma3.tistory.com/118 [토토모의 분석일지]
```

